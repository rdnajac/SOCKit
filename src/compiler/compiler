open Ast
open Bytecode

module StringMap = Map.Make(String)

(* Symbol table: Information about all the names in scope *)
type env = {
  function_index : int StringMap.t; (* Index for each function *)
  global_index : int StringMap.t; (* "Address" for global vars *)
  local_index : int StringMap.t; (* FP offset for args locals *)
}

(* enum : int -> 'a list -> (int * 'a) list *)
let rec enum stride n = function
  [] -> []
  | hd::tl -> (n, hd) :: enum stride (n+stride) tl

(* string_map_pairs:StringMap 'a -> (int * 'a) list -> StringMap 'a *)
let string_map_pairs map pairs =
  List.fold_left (fun m (i, n) -> StringMap.add n i m) map pairs

(** Translate a program in AST form into a bytecode program. Throw an
exception if something is wrong e.g. a reference to an unknown
variable or function *)
let translate (globals, functions) =

  (* Allocate "addresses" for each global variable *)
  let global_indexes =
    string_map_pairs StringMap.empty (enum 1 0 globals) in

  (* Assign indexes to function names; built-in "print" is special *)
  let built_in_functions =
    StringMap.add "print" (-1) StringMap.empty in
  let function_indexes = string_map_pairs built_in_functions
    (enum 1 1 (List.map (fun f -> f.fname) functions)) in

  (* Translate an AST function to a list of bytecode statements *)
  let translate env fdecl =
    (* Bookkeeping: FP offsets for locals and arguments *)
    let num_formals = List.length func_def.formals
    and num_locals = List.length fdecl.locals
    and local_offsets = enum 1 1 fdecl.locals
    and formal_offsets = enum (-1) (-2) fdecl.formals in
    let env = { env with local_index = string_map_pairs
                          StringMap.empty (local_offsets @ formal_offsets) } in

    (* Translate an expression *)
    let rec expr = function
      Literal i -> [Lit i]

      | Id s ->
        (try [Lfp (StringMap.find s env.local_index)]
         with Not_found -> try
             [Lod (StringMap.find s env.global_index)]
           with Not_found ->
             raise (Failure ("undeclared variable " ^ s)))

      | Binop (e1, op, e2) -> expr e1 @ expr e2 @ [Bin op]

      | Assign (s, e) -> expr e @
        (try [Sfp (StringMap.find s env.local_index)]
         with Not_found -> try
             [Str (StringMap.find s env.global_index)]
           with Not_found ->
             raise (Failure ("undeclared variable " ^ s)))

      | Call (fname, actuals) -> (try
            (List.concat (List.map expr (List.rev actuals))) @
            [Jsr (StringMap.find fname env.function_index) ]
          with Not_found ->
            raise (Failure ("undefined function " ^ fname)))

    (* Translate a statement *)
    in let rec stmt = function
      Block sl  -> List.concat (List.map stmt sl)

      | Expr e -> expr e @ [Drp] (* Discard result *)

      | Return e -> expr e @ [Rts num_formals]

      | If (p, t, f) -> let t' = stmt t and f' = stmt f in
                        expr p @ [Beq(2 + List.length t')] @
                        t' @ [Bra(1 + List.length f')] @ f'

      | While (e, b) ->
        let b' = stmt b and e' = expr e in
        [Bra (1+ List.length b')] @ b' @ e' @
        [Bne (-(List.length b' + List.length e'))]

    (* Translate a whole function *)
    in [Ent num_locals] @  (* Entry: allocate space for locals *)
       stmt (Block fdecl.body) @  (* Body *)
       [Lit 0; Rts num_formals]  (* Default = return 0 *)

  in let env = { function_index = function_indexes;
                 global_index = global_indexes;
                 local_index = StringMap.empty } in

  (* Code executed to start the program: Jsr main; halt *)
let entry_function = try
  [Jsr (StringMap.find "main" function_indexes); Hlt]
  with Not_found -> raise (Failure ("no \"main\" function"))

